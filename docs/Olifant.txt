-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package Olifant
@version 0.0.0.1

module Olifant.Core
data Ref a
Ref :: Text -> a -> Ref a
[$sel:rname:Ref] :: Ref a -> Text
[$sel:tipe:Ref] :: Ref a -> a
data Literal a
LNumber :: Int -> Literal a
LBool :: Bool -> Literal a
data Tipe
TInt :: Tipe
TBool :: Tipe
TArrow :: [Tipe] -> Tipe
data Expr a
Var :: (Ref a) -> Expr a
Lit :: (Literal a) -> Expr a
App :: (Expr a) -> (Expr a) -> Expr a
Lam :: Ref a -> Ref a -> Expr a -> Expr a
[$sel:name:Var] :: Expr a -> Ref a
[$sel:arg:Var] :: Expr a -> Ref a
[$sel:body:Var] :: Expr a -> Expr a
Let :: (Ref a) -> (Expr a) -> Expr a
type CoreUT = Expr ()
type Core = Expr Tipe

-- | Return type of a type
ret :: Tipe -> Tipe

-- | Arguments of a type
args :: Tipe -> Tipe
unit :: ()
instance Data.Traversable.Traversable Olifant.Core.Expr
instance Data.Foldable.Foldable Olifant.Core.Expr
instance GHC.Base.Functor Olifant.Core.Expr
instance GHC.Show.Show a => GHC.Show.Show (Olifant.Core.Expr a)
instance GHC.Show.Show Olifant.Core.Tipe
instance Data.Traversable.Traversable Olifant.Core.Literal
instance Data.Foldable.Foldable Olifant.Core.Literal
instance GHC.Base.Functor Olifant.Core.Literal
instance GHC.Show.Show (Olifant.Core.Literal a)
instance Data.Traversable.Traversable Olifant.Core.Ref
instance Data.Foldable.Foldable Olifant.Core.Ref
instance GHC.Base.Functor Olifant.Core.Ref
instance GHC.Show.Show a => GHC.Show.Show (Olifant.Core.Ref a)

module Olifant.Gen

-- | Symbol tables maps a name to a LLVM operand.
type SymbolTable = [(Text, Operand)]

-- | State of the complete program
data GenState
GenState :: [BlockState] -> SymbolTable -> Int -> Module -> GenState
[$sel:blocks:GenState] :: GenState -> [BlockState]
[$sel:symtab:GenState] :: GenState -> SymbolTable
[$sel:counter:GenState] :: GenState -> Int
[$sel:mod:GenState] :: GenState -> Module

-- | State of a single block
--   
--   A function definition contains a list of basic blocks, forming the
--   Control Flow Graph. Each basic block may optionally start with a
--   label, contains a list of instructions and ends with a terminator
--   instruction such as a branch or function return.
--   
--   As of now, a function contains just one block.
data BlockState
BlockState :: Text -> [Named Instruction] -> Maybe (Named Terminator) -> BlockState
[$sel:name:BlockState] :: BlockState -> Text
[$sel:stack:BlockState] :: BlockState -> [Named Instruction]
[$sel:term:BlockState] :: BlockState -> Maybe (Named Terminator)

-- | Codegen state monad
newtype Codegen a
Codegen :: State GenState a -> Codegen a
[$sel:runCodegen:Codegen] :: Codegen a -> State GenState a

-- | Default <a>GenState</a>
genState :: GenState

-- | Default <a>BlockState</a>
blockState :: Text -> BlockState
addDefn :: Global -> Codegen ()
addSym :: Text -> Operand -> Codegen ()

-- | Get the current block
current :: Codegen BlockState

-- | Push a named instruction to the stack of the active block
push :: Named Instruction -> Codegen ()

-- | Name an instruction and add to stack.
--   
--   <ul>
--   <li>Takes an expression of the form <tt>Add 1 2</tt></li>
--   <li>Gets a fresh name for it, <tt>%2</tt></li>
--   <li>Adds <tt>%2 = Add 1 2</tt> to the stack</li>
--   <li>Returns <tt>%2</tt></li>
--   </ul>
unnamed :: Tipe -> Instruction -> Codegen Operand

-- | Add the instruction to the stack with a specific name.
--   
--   <ul>
--   <li>Takes an expression of the form <tt>Add 1 2</tt> and a name
--   <tt>%foo</tt></li>
--   <li>Adds <tt>%foo = Add 1 2</tt> to the stack</li>
--   <li>Returns <tt>%foo</tt></li>
--   </ul>
named :: Tipe -> Text -> Instruction -> Codegen Operand

-- | Variable assignment
--   
--   Converts expression of the form <tt>%1 = 2</tt> to <tt>* %1 = 2</tt>
store :: Operand -> Operand -> Codegen ()

-- | Fetch a variable from memory
load :: Tipe -> Operand -> Codegen Operand

-- | Make an <a>alloca</a> instruction
alloca :: Tipe -> Maybe Text -> Codegen Operand

-- | Call a function <tt>fn</tt> with <a>$sel:arg:Var</a>
call :: Tipe -> Operand -> Operand -> Codegen Operand

-- | Add 2 integers
add :: Operand -> Operand -> Instruction

-- | Create a simple block from a list of instructions and a terminator
basicBlock :: [Named Instruction] -> Named Terminator -> BasicBlock

-- | Return the last expression from a block
terminator :: Operand -> Codegen (Named Terminator)

-- | Get a reference operand from a string
local :: Tipe -> Text -> Operand

-- | Get a global reference from a string
global :: Tipe -> Text -> Constant

-- | Map from Olifant types to LLVM types
native :: Tipe -> Type

-- | Get pointer to a local variable
--   
--   <pre>
--   i64 f -&gt; i64* f
--   </pre>
pointer :: Operand -> Operand

-- | Make an operand out of a global function
--   
--   %f -&gt; @f
externf :: Tipe -> Text -> Operand

-- | Define a function
define :: Ref Tipe -> Ref Tipe -> [BasicBlock] -> Codegen ()

-- | Find the operand for the variable from the symbol table and return it.
--   
--   Step through the AST
--   
--   Step should return an operand, which is the LHS of the operand it just
--   dealt with. Step is free to push instructions to the current block.
step :: Core -> Codegen Operand
compile :: [Core] -> Module

-- | Generate native code with C++ FFI
toLLVM :: Module -> IO Text

-- | Generate native code with C++ FFI
pretty :: [Core] -> Text

-- | Print compiled LLVM IR to stdout
genNative :: [Core] -> IO Text
instance Control.Monad.State.Class.MonadState Olifant.Gen.GenState Olifant.Gen.Codegen
instance GHC.Base.Monad Olifant.Gen.Codegen
instance GHC.Base.Applicative Olifant.Gen.Codegen
instance GHC.Base.Functor Olifant.Gen.Codegen
instance GHC.Show.Show Olifant.Gen.GenState
instance GHC.Show.Show Olifant.Gen.BlockState


module Olifant.Calculus
data Calculus
Var :: Text -> Calculus
Number :: Int -> Calculus
Bool :: Bool -> Calculus
App :: Calculus -> Calculus -> Calculus
Lam :: Text -> Calculus -> Calculus
Let :: Text -> Calculus -> Calculus
instance GHC.Show.Show Olifant.Calculus.Calculus
instance GHC.Classes.Eq Olifant.Calculus.Calculus


module Olifant.Compiler

-- | Quickly translate calculus into untyped core
--   
--   This is a dumb stupid pass which is making me reconsider having the
--   Calculus type at all. Maybe I can just avoid Calculus type and parse
--   into CoreUT directly.
cast :: Calculus -> CoreUT

-- | Find undefined variables
--   
--   This one can serve as an example for a nano pass!
undef :: CoreUT -> Either Text CoreUT


module Olifant.Parser

-- | Parse a signed integer
number :: Parsec Text st Calculus

-- | Parse a word as an identifier
symbol :: Parsec Text st Calculus

-- | Parse scheme style boolean
--   
--   Try is required on the left side of <a>|</a> to prevent eagerly
--   consuming #
bool :: Parsec Text st Calculus

-- | Parse expressions of the form <tt>x.x</tt>
lambda :: Parsec Text st Calculus

-- | A term, which is anything except lambda application
term :: Parsec Text st Calculus

-- | The lambda calculus grammar
calculus :: Parsec Text st Calculus
parser :: Parsec Text st [Calculus]

-- | Squeeze a parser between something else and throw away the padding
squeeze :: Stream s m t => ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a

-- | Parse source and return AST
--   
--   Converting ParseError to Text is losing information, but helps compose
--   elsewhere. See <a>exec</a> for example. This is alright because I'm
--   not doing anything else with it right now.
read :: Text -> Either Text [Calculus]

module Olifant
compile :: [Core] -> Module

-- | Map from Olifant types to LLVM types
native :: Tipe -> Type

-- | Generate native code with C++ FFI
pretty :: [Core] -> Text
