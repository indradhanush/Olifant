* What I would like to do with Olifant and the things I learned [0/9]

- [ ] Compile a series of expressions, where last one is main
- [ ] Define single argument lambdas
- [ ] Call lambda
- [ ] Define global variables
- [ ] Add numeric and boolean types

  Experiment with a literal type and see how that goes

  #+BEGIN_SRC haskell
  -- | Literal values in the language
  data Lit = LInt Int | LBool Bool
        deriving (Show, Eq, Ord)
  #+END_SRC

- [ ] Add a proper symbol table
- [ ] Add error checks and validation
- [ ] Write a frontend
- [ ] Explore the options with a second lower level IR

  A lower level IR seems necessary at this point.

  1. Non recursive grammar.
  2. SSA form.
  3. Explicitly named functions at top level
  4.

* Compilation phases

1. Parser

Parse string into an *untyped* AST of the form

#+BEGIN_SRC haskell
  data E = Num Int | Var String ...
#+END_SRC

#+BEGIN_QUOTE
GHC's parser is purely functional. In fact, the API of the GHC library provides
a pure function called parser that takes a String (and a few other things) and
returns either the parsed abstract syntax or an error message.
#+END_QUOTE

2. Lint

Rename and type check symbols. I might be able to get rid of the symbol tables
after this step. A variable reference should be of the form

#+BEGIN_SRC haskell
  data Var = Var {name :: String, type :: Type, ...}
#+END_SRC

#+BEGIN_QUOTE
Renaming is the process of resolving all of the identifiers in the Haskell
source code into fully qualified names, at the same time identifying any
out-of-scope identifiers and flagging errors appropriately.
#+END_QUOTE
